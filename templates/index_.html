{% extends "base.html" %}

{% block title %}Home - Electric Circuit Analyzer{% endblock %}

{% block content %}
    <div class="container">
        <div class="upload-section">
            <form id="upload-form" enctype="multipart/form-data">
                <div class="file-input-wrapper">
                    <input type="file" name="pdf_file" id="pdf-file" accept="application/pdf" required>
                    <label for="pdf-file" class="file-input-label">
                        📄 Choose PDF File
                    </label>
                </div>

                <input type="text" name="page_num" id="selected-pages" placeholder="Page Number" style="display: none;">

                <!-- Analysis button - initially hidden -->
                <button type="submit" class="submit-btn" id="submit-btn" style="display: none;">
                    📤 Upload & Analyze
                </button>
            </form>

            <!-- Page Selection button - initially hidden -->
            <!-- <button type="button" class="page-select-btn" id="page-select-btn" style="display: none;" onclick="enablePageSelection()">
                📑 Select Pages
            </button> -->

            <div id="upload-status"></div>

            <!-- File selection status -->
            <div id="file-status" class="file-status">
                <div id="pdf-file-status">PDF: Not selected</div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab" id="pdf-preview-tab" onclick="showTab('pdf-preview')" style="display: none;">📄 PDF
                Preview</button>
            <button class="tab active" onclick="showTab('selected-pdf-pages')">📄 Selected Pages</button>
            <button class="tab" onclick="showTab('dataframes')">📊 Data Tables</button>
            <button class="tab" onclick="showTab('drawn-lines')">📝 Drawn Lines</button>
        </div>

        <!-- PDF Preview Tab -->
        <div id="pdf-preview" class="tab-content">
            <div class="pdf-container">
                <div class="pdf-header">
                    <div class="pdf-title">📄 PDF Preview</div>
                    <div class="pdf-info">
                        <span id="pdf-name">No file selected</span>
                        <span>•</span>
                        <span>Page <span id="current-pdf-page">1</span> of <span id="total-pdf-pages">1</span></span>
                    </div>
                </div>

                <div class="pdf-controls">
                    <button class="page-btn" id="pdf-prev-btn" onclick="changePdfPage(-1)">
                        ← Previous
                    </button>
                    <input type="number" id="pdf-page-input" min="1" value="1" onchange="goToPdfPage()">
                    <button class="page-btn" id="pdf-next-btn" onclick="changePdfPage(1)">
                        Next →
                    </button>
                    <button class="page-btn select-btn" id="select-toggle-btn" onclick="toggleSelection()">
                        ✓ Select Pages
                    </button>
                </div>

                <div class="selection-controls" id="selection-controls">
                    <div class="selection-row">
                        <button class="clear-selection-btn" id="clear-selection-btn" onclick="clearSelection()">
                            🗑️ Clear
                        </button>
                    </div>
                </div>

                <div class="pdf-display">
                    <canvas id="pdf-canvas"></canvas>
                    <div class="selection-indicator" id="selection-indicator">
                        ✓ Page Selected
                    </div>
                </div>
            </div>
        </div>

        <div id="selected-pdf-pages" class="tab-content active">
            <div class="pdf-container">
                <div class="pdf-header">
                    <div class="pdf-title">📄 Selected Pages</div>
                    <div class="pdf-info">
                        <span id="selected-pdf-name">No pages selected</span>
                        <span id="selected-pages-info" style="display: none;">•</span>
                        <span id="selected-pages-display" style="display: none;">Pages: <span id="selected-pages-list">None</span></span>
                    </div>
                </div>

                <div class="pdf-controls" id="selected-pdf-controls" style="display: none;">
                    <button class="page-btn" id="selected-pdf-prev-btn" onclick="changeSelectedPdfPage(-1)">
                        ← Previous
                    </button>
                    <span class="current-page">Page <span id="current-selected-page">1</span> of <span id="total-selected-pages">0</span></span>
                    <button class="page-btn" id="selected-pdf-next-btn" onclick="changeSelectedPdfPage(1)">
                        Next →
                    </button>
                    <button class="page-btn component-btn" id="draw-components-btn" onclick="drawComponents()">
                        🎨 Draw Components
                    </button>
                </div>

                <!-- Component Drawing Controls -->
                <div class="component-controls" id="component-controls" style="display: none;">
                    <div class="component-row">
                        <label>Width: <input type="number" id="componentWidth" value="20" min="10" max="200"></label>
                        <label>Height: <input type="number" id="componentHeight" value="20" min="10" max="200"></label>
                        <button class="page-btn" id="exit-component-mode" onclick="exitComponentMode()">
                            ✗ Exit Drawing Mode
                        </button>
                        <button class="download-btn" onclick="downloadModifiedPDF()">
                            📥 Download Modified PDF
                        </button>
                    </div>
                    <div class="coordinates-display" id="coordinates-display" style="display: none;">
                        Click coordinates will appear here
                    </div>
                </div>

                <div class="pdf-display" id="selected-pdf-display">
                    <div class="no-selection-message">
                        <p>No pages selected yet.</p>
                        <p>Click "Select Pages" above to choose pages from your PDF.</p>
                    </div>
                    <canvas id="selected-pdf-canvas" style="display: none;"></canvas>
                    <div id="component-overlay" style="position: absolute; top: 0; left: 0; pointer-events: none;"></div>
                </div>
            </div>
        </div>

        <div id="dataframes" class="tab-content">
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Connection Analysis Data</div>

                    <button class="download-btn" id="save-btn" onclick="saveToDatabase('connection-data')">
                        📥 Save to Database
                    </button>

                    <div class="toast-custom-container" id="toast-custom-container"></div>

                    <button class="download-btn" onclick="downloadCSV('connection-data')">
                        📥 Download CSV
                    </button>
                </div>

                <div class="table-wrapper">
                    <table id="connection-table">
                        <thead id="connection-thead"></thead>
                        <tbody id="connection-tbody"></tbody>
                    </table>
                </div>
            </div>
            <div class="table-container">
                <div class="table-header">
                    <div class="table-title">Connection Pairs</div>
                    <button class="download-btn" onclick="downloadCSV('connection-pairs')">
                        📥 Download CSV
                    </button>
                </div>
            </div>
        </div>

        <!-- Analysis Images Tab -->
        <div id="analysis-images" class="tab-content">
            <div class="image-container">
                <div class="image-header">🖼️ Combined Canvas</div>
                <div class="image-display">
                    <img id="combined-canvas" src="" alt="Combined Canvas" />
                </div>
            </div>

            <div class="image-container">
                <div class="image-header">📍 Junction Points</div>
                <div class="image-display">
                    <img id="junction-points" src="" alt="Junction Points" />
                </div>
            </div>

            <div class="image-container">
                <div class="image-header">📏 Line Canvas</div>
                <div class="image-display">
                    <img id="line-canvas" src="" alt="Line Canvas" />
                </div>
            </div>
        </div>

        <!-- Drawn Lines Tab -->
        <div id="drawn-lines" class="tab-content">
            <div class="pagination-container">
                <div class="pagination-header">
                    <div class="pagination-title">Drawn Lines Collection</div>
                    <div class="pagination-info">
                        Showing <span id="current-range">0-0</span> of <span id="total-images">0</span> images
                    </div>
                </div>
                <div class="pagination-controls">
                    <button class="page-btn" id="prev-btn" onclick="changePage(-1)">← Previous Page</button>
                    <span class="current-page">Page <span id="current-page">1</span> of <span id="total-pages">1</span></span>
                    <button class="page-btn" id="next-btn" onclick="changePage(1)">Next Page →</button>
                </div>

                <div class="pagination-controls">
                    <button class="page-btn" id="prev-image-btn" onclick="changeImagePage(-1)">← Prev 10</button>
                    <span id="image-page-info">Image Page 1 of 1</span>
                    <button class="page-btn" id="next-image-btn" onclick="changeImagePage(1)">Next 10 →</button>
                </div>
                <div class="images-grid" id="images-grid">
                    <!-- Images will be dynamically populated here -->
                </div>
            </div>
        </div>

        <!-- Overlay for image popup -->
        <div class="overlay" id="image-overlay">
            <div class="overlay-content" id="overlay-content">
                <button class="close-btn" onclick="closeOverlay()">&times;</button>
                <button class="nav-arrow prev" id="prev-overlay" onclick="navigateOverlay(-1)">&#8249;</button>
                <img class="overlay-image" id="overlay-image" src="" alt="">
                <button class="nav-arrow next" id="next-overlay" onclick="navigateOverlay(1)">&#8250;</button>
                <div class="overlay-info" id="overlay-info"></div>
            </div>
        </div>
    </div>

    <style>
        .page-select-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .page-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .no-selection-message {
            text-align: center;
            padding: 60px 20px;
            color: #666;
            font-size: 16px;
            line-height: 1.6;
        }

        .no-selection-message p {
            margin: 10px 0;
        }

        .component-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white !important;
        }

        .component-btn:hover {
            background: linear-gradient(135deg, #ee5a24, #ff6b6b);
        }

        .component-controls {
            background: #f8f9fa;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
        }

        .component-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .component-row label {
            font-weight: 600;
        }

        .component-row input {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            margin-left: 5px;
        }

        .coordinates-display {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            margin-top: 10px;
            font-family: monospace;
        }

        .pdf-display canvas {
            transition: cursor 0.2s ease;
        }

        .pdf-display canvas.drawing-mode {
            cursor: crosshair !important;
        }

        .pdf-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #666;
        }
        #component-overlay .component-box {
            transition: all 0.2s ease-in-out;
        }

    </style>

    <script>
        // PDF.js setup
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDoc = null;
        let currentPdfPage = 1;
        let totalPdfPages = 1;
        let isSelectionMode = false;
        let isComponentDrawMode = false;
        const imagesPerPage = 20;
        let selectedPages = new Set();
        let selectedPagesArray = []; // Array version for navigation
        let currentSelectedPageIndex = 0;
        let sampleData = {};
        let currentPage = 1;
        let totalImages = 0;
        let pdfFileName = '';
        let originalPageWidth = 0;
        let originalPageHeight = 0;
        let scaleX = 1;
        let scaleY = 1;
        const pageComponents = {}; // { pageNum: [ {x, y, width, height} ] }
        let unique_id = 0

        
        // File input handlers with proper event binding
        document.addEventListener('DOMContentLoaded', function () {
            // PDF file input handler
            const pdfInput = document.getElementById('pdf-file');
            const pdfLabel = document.querySelector('label[for="pdf-file"]');
            const pdfStatus = document.getElementById('pdf-file-status');

            if (pdfInput && pdfLabel) {
                // Handle file selection
                pdfInput.addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (file) {
                        if (file.type === 'application/pdf') {
                            pdfStatus.textContent = `PDF: ${file.name}`;
                            pdfFileName = file.name;
                            pdfStatus.classList.add('file-selected');

                            // Load PDF for preview
                            loadPDF(file);
                            document.getElementById('pdf-name').textContent = file.name;
                            document.getElementById('selected-pdf-name').textContent = file.name;

                            // Show page selection button
                            document.getElementById('page-select-btn').style.display = 'inline-block';

                            // Hide analysis button until pages are selected
                            document.getElementById('submit-btn').style.display = 'none';

                            // Reset selection state
                            isSelectionMode = false;
                            selectedPages.clear();
                            selectedPagesArray = [];
                            updateSelectionUI();
                            updateSelectedPagesDisplay();
                        } else {
                            pdfStatus.textContent = 'PDF: Invalid file type';
                            pdfStatus.classList.remove('file-selected');
                        }
                    } else {
                        pdfStatus.textContent = 'PDF: Not selected';
                        pdfStatus.classList.remove('file-selected');
                        document.getElementById('page-select-btn').style.display = 'none';
                        document.getElementById('submit-btn').style.display = 'none';
                    }
                });

                // Handle label click
                pdfLabel.addEventListener('click', function (e) {
                    e.preventDefault();
                    pdfInput.click();
                });
            }
        });
function renderComponentOverlays(pageNum) {
    console.log('renderComponentOverlays called for page:', pageNum);
    const overlay = document.getElementById('component-overlay');
    if (!overlay) {
        console.error('Component overlay element not found');
        return;
    }
    
    overlay.innerHTML = ''; // Clear old boxes

    if (!pageComponents[pageNum]) {
        console.log('No components for page:', pageNum);
        return;
    }

    console.log('Rendering', pageComponents[pageNum].length, 'components');
    pageComponents[pageNum].forEach(c => {
        drawComponentOverlay(c.x, c.y, c.width, c.height);
    });
}

        function enablePageSelection() {
            // Show PDF preview tab and switch to it
            const pdfTab = document.getElementById('pdf-preview-tab');
            pdfTab.style.display = 'flex';
            showTab('pdf-preview');
            
            // Enable selection mode
            isSelectionMode = true;
            updateSelectionUI();
            
            // Add click handler to canvas for page selection
            document.getElementById('pdf-canvas').addEventListener('click', handlePageSelection);
        }

        function loadPDF(file) {
            const fileReader = new FileReader();

            fileReader.onload = function () {
                const typedarray = new Uint8Array(this.result);
                let submitBtn = document.getElementById('submit-btn');
                pdfjsLib.getDocument(typedarray).promise.then(function (pdf) {
                    pdfDoc = pdf;
                    totalPdfPages = pdf.numPages;
                    document.getElementById('total-pdf-pages').textContent = totalPdfPages;
                    document.getElementById('pdf-page-input').max = totalPdfPages;
                    
                    currentPdfPage = 1;
                    renderPdfPage(currentPdfPage);
                    enablePageSelection();

                    const pdfFileInput = document.getElementById('pdf-file');
                    if (!pdfFileInput.files.length) {
                        alert('No PDF file available');
                        return;
                    }

                    // First upload the PDF file to the backend (similar to the white box editor)
                    const formData = new FormData();
                    formData.append('pdf_file', pdfFileInput.files[0]);
                    console.log(formData);
                    fetch('/optimize', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('PDF uploaded successfully:', data);
                            submitBtn.style.display = 'inline-block';
                        } else {
                            console.error('Error uploading PDF:', data.error);
                            submitBtn.style.display = 'none';
                        }
                    })
                    .catch(function (error) {
                        console.error('Error uploading PDF:', error);
                        submitBtn.style.display = 'none';
                    });
                }).catch(function (error) {
                    console.error('Error loading PDF document', error);
                    submitBtn.style.display = 'none';
                });
            };

            fileReader.onerror = function () {
                console.error('FileReader error', fileReader.error);
            };

            fileReader.readAsArrayBuffer(file);
        }

function renderPdfPage(pageNumber, canvasId = 'pdf-canvas') {
    console.log('renderPdfPage called with:', pageNumber, canvasId);
    
    if (!pdfDoc) {
        console.error('pdfDoc is null');
        return;
    }
    
    pdfDoc.getPage(pageNumber).then(function (page) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error('Canvas not found:', canvasId);
            return;
        }
        
        const context = canvas.getContext('2d');

        // Calculate scale based on container width
        const container = canvas.parentElement;
        let containerWidth = container.clientWidth;
        
        // More robust container width calculation
        if (containerWidth <= 60) {
            // Fallback: use a reasonable default width
            containerWidth = 1258;
            console.warn('Container width too small, using fallback:', containerWidth);
        } else {
            // Only subtract padding if we have enough width
            containerWidth = containerWidth - 60;
        }
        
        console.log('Container width:', container.clientWidth, 'Adjusted width:', containerWidth);
        
        const viewport = page.getViewport({ scale: 1 });
        console.log('Original viewport:', viewport.width, 'x', viewport.height);
        
        // Store original page dimensions
        if (canvasId === 'selected-pdf-canvas') {
            originalPageWidth = viewport.width;
            originalPageHeight = viewport.height;
        }
        
        // Ensure minimum scale and reasonable maximum
        let scale = Math.min(containerWidth / viewport.width, 1.5);
        scale = Math.max(scale, 0.3); // Minimum scale of 0.3
        
        const scaledViewport = page.getViewport({ scale: scale });
        
        console.log('Scale factor:', scale);
        console.log('Scaled viewport:', scaledViewport.width, 'x', scaledViewport.height);

        // Ensure reasonable canvas dimensions
        canvas.width = Math.max(scaledViewport.width, 100);
        canvas.height = Math.max(scaledViewport.height, 100);
        
        console.log('Canvas dimensions set:', canvas.width, 'x', canvas.height);

        // Calculate scale factors for coordinate conversion
        if (canvasId === 'selected-pdf-canvas') {
            scaleX = canvas.width / originalPageWidth;
            scaleY = canvas.height / originalPageHeight;
            console.log('Scale factors:', scaleX, scaleY);
        }

        const renderContext = {
            canvasContext: context,
            viewport: scaledViewport
        };

        page.render(renderContext).promise.then(function () {
            console.log('Page render completed successfully');
            
            if (canvasId === 'pdf-canvas') {
                document.getElementById('current-pdf-page').textContent = pageNumber;
                document.getElementById('pdf-page-input').value = pageNumber;
                document.getElementById('pdf-prev-btn').disabled = pageNumber <= 1;
                document.getElementById('pdf-next-btn').disabled = pageNumber >= totalPdfPages;
                updateSelectionIndicator();
            } else if (canvasId === 'selected-pdf-canvas') {
                renderComponentOverlays(pageNumber);
            }
        }).catch(function (error) {
            console.error('Error rendering PDF page:', error);
        });
    }).catch(function (error) {
        console.error('Error getting PDF page:', error);
    });
}

        function attachScrollListener() {
            const pdfCanvas = document.getElementById("pdf-canvas");

            if (!pdfCanvas || pdfCanvas.dataset.wheelBound) return; // avoid duplicate bindings
            pdfCanvas.addEventListener("wheel", handlePdfScroll, { passive: false });
            pdfCanvas.dataset.wheelBound = "true"; // mark as bound
        }

        function handlePdfScroll(e) {
            if (e.deltaY > 0) {
                changePdfPage(1);
            } else {
                changePdfPage(-1);
            }
            e.preventDefault();
        }

        function changePdfPage(delta) {
            const newPage = currentPdfPage + delta;
            if (newPage >= 1 && newPage <= totalPdfPages) {
                currentPdfPage = newPage;
                renderPdfPage(currentPdfPage);
            }
        }

        function goToPdfPage() {
            const pageInput = document.getElementById('pdf-page-input');
            const page = parseInt(pageInput.value);
            if (page >= 1 && page <= totalPdfPages) {
                currentPdfPage = page;
                renderPdfPage(currentPdfPage);
            } else {
                pageInput.value = currentPdfPage;
            }
        }

        function toggleSelection() {
            isSelectionMode = !isSelectionMode;
            updateSelectionUI();

            if (isSelectionMode) {
                // Add click handler to canvas for page selection
                document.getElementById('pdf-canvas').addEventListener('click', handlePageSelection);
            } else {
                // Remove click handler
                document.getElementById('pdf-canvas').removeEventListener('click', handlePageSelection);
            }
        }

function handlePageSelection() {
    if (!isSelectionMode) return;

    if (selectedPages.has(currentPdfPage)) {
        selectedPages.delete(currentPdfPage);
    } else {
        selectedPages.add(currentPdfPage);
    }

    // IMPORTANT: Update both the input and display in the correct order
    updateSelectedPagesInput(); // This updates selectedPagesArray
    updateSelectionIndicator();
    updateSelectedPagesDisplay(); // This uses selectedPagesArray
    
    // Show/hide analyze button based on selection
    const submitBtn = document.getElementById('submit-btn');
    if (selectedPages.size > 0) {
        submitBtn.style.display = 'inline-block';
    } else {
        submitBtn.style.display = 'none';
    }
}

        function updateSelectionUI() {
            const selectBtn = document.getElementById('select-toggle-btn');
            const selectionControls = document.getElementById('selection-controls');

            if (isSelectionMode) {
                selectBtn.textContent = '✗ Exit Selection';
                selectBtn.classList.add('active');
                selectionControls.classList.add('active');
            } else {
                selectBtn.textContent = '✓ Select Pages';
                selectBtn.classList.remove('active');
                selectionControls.classList.remove('active');
            }
        }

       function updateSelectedPagesInput() {
    const input = document.getElementById('selected-pages');
    const sortedPages = Array.from(selectedPages).sort((a, b) => a - b);
    
    // IMPORTANT: Update selectedPagesArray here consistently
    selectedPagesArray = sortedPages;

    if (sortedPages.length === 0) {
        input.value = '';
        return;
    }

    // Convert to ranges for better readability
    const ranges = [];
    let start = sortedPages[0];
    let end = start;

    for (let i = 1; i <= sortedPages.length; i++) {
        if (i < sortedPages.length && sortedPages[i] === end + 1) {
            end = sortedPages[i];
        } else {
            if (start === end) {
                ranges.push(start.toString());
            } else if (end === start + 1) {
                ranges.push(start.toString(), end.toString());
            } else {
                ranges.push(`${start}-${end}`);
            }
            if (i < sortedPages.length) {
                start = sortedPages[i];
                end = start;
            }
        }
    }

    input.value = ranges.join(', ');
}

        function updateSelectionIndicator() {
            const indicator = document.getElementById('selection-indicator');

            if (isSelectionMode && selectedPages.has(currentPdfPage)) {
                indicator.classList.add('show');
            } else {
                indicator.classList.remove('show');
            }
        }


function updateSelectedPagesDisplay() {
    console.log('updateSelectedPagesDisplay called');
    
    const selectedPdfName = document.getElementById('selected-pdf-name');
    const selectedPagesInfo = document.getElementById('selected-pages-info');
    const selectedPagesDisplay = document.getElementById('selected-pages-display');
    const selectedPagesList = document.getElementById('selected-pages-list');
    const selectedPdfControls = document.getElementById('selected-pdf-controls');
    const selectedPdfCanvas = document.getElementById('selected-pdf-canvas');
    const noSelectionMessage = document.querySelector('.no-selection-message');

    if (selectedPages.size === 0) {
        selectedPagesInfo.style.display = 'none';
        selectedPagesDisplay.style.display = 'none';
        selectedPdfControls.style.display = 'none';
        selectedPdfCanvas.style.display = 'none';
        noSelectionMessage.style.display = 'block';
        selectedPdfName.textContent = 'No pages selected';
    } else {
        selectedPagesInfo.style.display = 'inline';
        selectedPagesDisplay.style.display = 'inline';
        selectedPdfControls.style.display = 'flex';
        selectedPdfCanvas.style.display = 'block';
        noSelectionMessage.style.display = 'none';
        selectedPdfName.textContent = pdfFileName;
        
        // Update selected pages list display
        const sortedPages = Array.from(selectedPages).sort((a, b) => a - b);
        selectedPagesList.textContent = sortedPages.join(', ');
        document.getElementById('total-selected-pages').textContent = selectedPages.size;
        
        selectedPagesArray = sortedPages;
        
        if (selectedPagesArray.length > 0) {
            currentSelectedPageIndex = 0;
            const pageToRender = selectedPagesArray[currentSelectedPageIndex];
            
            // Ensure proper container sizing before rendering
            setTimeout(() => {
                ensureCanvasContainerSize();
                renderPdfPage(pageToRender, 'selected-pdf-canvas');
                updateSelectedPageNavigation();
            }, 150); // Slightly longer delay to ensure DOM is ready
        }
    }
}
function ensureCanvasContainerSize() {
    const selectedPdfDisplay = document.getElementById('selected-pdf-display');
    if (selectedPdfDisplay) {
        // Force a minimum width if not set
        const computedStyle = window.getComputedStyle(selectedPdfDisplay);
        const width = parseInt(computedStyle.width);
        console.log('Selected PDF display width:', width);
        
        if (width < 100) {
            selectedPdfDisplay.style.width = '800px';
            selectedPdfDisplay.style.minHeight = '600px';
            console.log('Set fallback dimensions for selected PDF display');
        }
    }
}


        function changeSelectedPdfPage(delta) {
            const newIndex = currentSelectedPageIndex + delta;
            if (newIndex >= 0 && newIndex < selectedPagesArray.length) {
                currentSelectedPageIndex = newIndex;
                renderPdfPage(selectedPagesArray[currentSelectedPageIndex], 'selected-pdf-canvas');
                updateSelectedPageNavigation();
            }
        }

        function updateSelectedPageNavigation() {
            document.getElementById('current-selected-page').textContent = currentSelectedPageIndex + 1;
            document.getElementById('selected-pdf-prev-btn').disabled = currentSelectedPageIndex === 0;
            document.getElementById('selected-pdf-next-btn').disabled = currentSelectedPageIndex === selectedPagesArray.length - 1;
        }

        function drawComponents() {
            // Enable component drawing mode
            isComponentDrawMode = true;
            updateComponentDrawUI();
            
            // Show component controls
            document.getElementById('component-controls').style.display = 'block';
            
            // Add drawing mode class to canvas
            const canvas = document.getElementById('selected-pdf-canvas');
            if (canvas) {
                canvas.classList.add('drawing-mode');
                canvas.addEventListener('click', handleComponentPlacement);
                canvas.addEventListener('mousemove', showCoordinates);
            }
        }

        function updateComponentDrawUI() {
            const drawBtn = document.getElementById('draw-components-btn');
            if (isComponentDrawMode) {
                drawBtn.textContent = '🎨 Drawing Mode Active';
                drawBtn.disabled = true;
            } else {
                drawBtn.textContent = '🎨 Draw Components';
                drawBtn.disabled = false;
            }
        }

        function exitComponentMode() {
            isComponentDrawMode = false;
            updateComponentDrawUI();
            
            // Hide component controls
            document.getElementById('component-controls').style.display = 'none';
            
            // Remove drawing mode from canvas
            const canvas = document.getElementById('selected-pdf-canvas');
            if (canvas) {
                canvas.classList.remove('drawing-mode');
                canvas.removeEventListener('click', handleComponentPlacement);
                canvas.removeEventListener('mousemove', showCoordinates);
            }
            
            // Hide coordinates display
            document.getElementById('coordinates-display').style.display = 'none';
        }

        function handleComponentPlacement(event) {
            if (!isComponentDrawMode) return;

            const canvas = event.currentTarget;
            const canvasRect = canvas.getBoundingClientRect();

            // Calculate coordinates relative to the canvas
            const canvasX = event.clientX - canvasRect.left;
            const canvasY = event.clientY - canvasRect.top;

            // Convert to PDF coordinates
            const pdfX = canvasX / scaleX;
            const pdfY = canvasY / scaleY;

            const width = parseInt(document.getElementById('componentWidth').value);
            const height = parseInt(document.getElementById('componentHeight').value);
            const currentPagePdf = selectedPagesArray[currentSelectedPageIndex];

            // Save this component to the pageComponents object
            if (!pageComponents[currentPagePdf]) pageComponents[currentPagePdf] = [];
            pageComponents[currentPagePdf].push({ x: pdfX, y: pdfY, width, height });

            // Draw immediately for UI feedback
            drawComponentOverlay(pdfX, pdfY, width, height);

            // Show coordinates
            const coordsDisplay = document.getElementById('coordinates-display');
            coordsDisplay.textContent = `Adding component at: X=${pdfX.toFixed(1)}, Y=${pdfY.toFixed(1)} on page ${currentPagePdf}`;
            coordsDisplay.style.display = 'block';

            // Call backend to save to PDF
            addWhiteBoxToPDF(currentPagePdf - 1, pdfX, pdfY, width, height);
        }
        function showCoordinates(event) {
            if (!isComponentDrawMode) return;

            const canvas = event.currentTarget;
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate coordinates relative to the canvas
            const canvasX = event.clientX - canvasRect.left;
            const canvasY = event.clientY - canvasRect.top;
            
            // Convert to PDF coordinates
            const pdfX = canvasX / scaleX;
            const pdfY = canvasY / scaleY;

            const coordsDisplay = document.getElementById('coordinates-display');
            coordsDisplay.textContent = `Mouse at: X=${pdfX.toFixed(1)}, Y=${pdfY.toFixed(1)}`;
            coordsDisplay.style.display = 'block';
        }

        function drawComponentOverlay(x, y, width, height) {
            const canvas = document.getElementById('selected-pdf-canvas');
            const overlay = document.getElementById('component-overlay');
            
            if (!canvas || !overlay) return;

            // Convert PDF coords back to canvas coords
            const canvasW = width * scaleX;
            const canvasH = height * scaleY;
            const canvasX = x * scaleX + canvasW / 2;  // shift left by half width
            const canvasY = y * scaleY + canvasH / 2;  // shift up by half height

            const box = document.createElement('div');
            box.classList.add('component-box');
            box.style.position = 'absolute';
            box.style.left = `${canvasX}px`;
            box.style.top = `${canvasY}px`;
            box.style.width = `${canvasW}px`;
            box.style.height = `${canvasH}px`;
            box.style.border = '2px solid red';
            box.style.background = 'rgba(255, 0, 0, 0.1)';
            box.style.borderRadius = '4px';

            overlay.appendChild(box);
        }

        function addWhiteBoxToPDF(pageNum, x, y, width, height) {
            // Create FormData to upload current PDF if needed
            const pdfFileInput = document.getElementById('pdf-file');
            if (!pdfFileInput.files.length) {
                alert('No PDF file available');
                return;
            }
            unique_id+=1
            // First upload the PDF file to the backend (similar to the white box editor)
            const formData = new FormData();
            formData.append('file', pdfFileInput.files[0]);

            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Now add the white box
                    return fetch('/add_white_box', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            filename: data.filename,
                            page_num: pageNum,
                            x: x,
                            y: y,
                            width: width,
                            height: height,
                            unique_id: unique_id
                        })
                    });
                } else {
                    throw new Error(data.error);
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Draw the box visually on the current canvas
                    drawComponentOverlay(x, y, width, height);

                    // Refresh the PDF if you want (optional)
                    renderPdfPage(selectedPagesArray[currentSelectedPageIndex], 'selected-pdf-canvas');
                } else {
                    alert('Error adding component: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error adding component:', error);
                alert('Error adding component: ' + error.message);
            });
        }

        function downloadModifiedPDF() {
            const pdfFileInput = document.getElementById('pdf-file');
            if (!pdfFileInput.files.length) {
                alert('No PDF file available for download');
                return;
            }

            // Create a temporary filename based on the original
            const originalName = pdfFileInput.files[0].name;
            const modifiedName = `modified_${originalName}`;
            
            // This would need to be implemented in the backend
            fetch(`/download_modified/${originalName}`)
            .then(response => {
                if (response.ok) {
                    return response.blob();
                }
                throw new Error('Download failed');
            })
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = modifiedName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            })
            .catch(error => {
                console.error('Download error:', error);
                alert('Error downloading modified PDF: ' + error.message);
            });
        }

        function clearSelection() {
            selectedPages.clear();
            selectedPagesArray = [];
            updateSelectedPagesInput();
            updateSelectionIndicator();
            updateSelectedPagesDisplay();
            document.getElementById('submit-btn').style.display = 'none';
        }

        // Tab switching function
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
            }

            // Add active class to clicked tab (find it by onclick content or other means)
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                if (tab.onclick && tab.onclick.toString().includes(tabName)) {
                    tab.classList.add('active');
                }
            });
        }

        // Form submission handler
        document.getElementById('upload-form').addEventListener('submit', function (event) {
            event.preventDefault();

            const pdfFileInput = document.getElementById('pdf-file');
            const pageNumInput = document.getElementById('selected-pages');
            const submitBtn = document.getElementById('submit-btn');
            const statusDiv = document.getElementById('upload-status');

            if (!pdfFileInput.files.length) {
                statusDiv.textContent = "❌ Please select a PDF file";
                statusDiv.className = "status-error";
                return;
            }

            if (!pageNumInput.value) {
                statusDiv.textContent = "❌ Please select pages first";
                statusDiv.className = "status-error";
                return;
            }

            const formData = new FormData();
            formData.append('pdf_file', pdfFileInput.files[0]);
            formData.append('page_num', pageNumInput.value);
            formData.append('enable_network_colors', 'true');

            // Disable submit button and show loading
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<div class="loading"></div> Analyzing...';
            statusDiv.textContent = "⏳ Uploading and analyzing...";
            statusDiv.className = "status-info";
            // Note: This will fail in the demo as there's no backend
            unique_id = 0
            fetch('/analyze', {
                method: 'POST',
                body: formData
            })
                .then(res => {
                    return res.json();
                })
                .then(data => {
                    if (!data.success) {
                        throw new Error(data.error || "Analysis failed");
                    }

                    // Process the results here
                    statusDiv.textContent = "✅ Analysis complete!";
                    statusDiv.className = "status-success";
                    console.log('Analysis results:', data.result);
                    sampleData = {
                        wireData: data.result.wire_data || [],
                        connectionData: data.result.connection_data || [],
                        images: data.result.images || [],
                        drawnLines: data.result.drawn_lines || []
                    };
                    initializePage();

                })
                .catch(err => {
                    console.error('Error during analysis', err);
                    statusDiv.textContent = "❌ " + (err.message || "Network error - no backend available in demo");
                    statusDiv.className = "status-error";
                })
                .finally(() => {
                    // Re-enable submit button
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = '📤 Upload & Analyze';
                });
        });


        function populateConnectionTable(data) {
            console.log('Populating connection table with data:', data);
            const columnOrder = [
                "index_no",
                "source_component",
                "source_terminal",
                "dest_component",
                "dest_terminal",
                "wire_no",
                "page_number",
                "reason",
                "pdf_name" // keep it in the object, just don't display it
            ];
            if (data == undefined || data.length === 0) return;

            data = data.map(row => {
                const reorderedRow = {};
                columnOrder.forEach(col => {
                    if (row.hasOwnProperty(col)) {
                        reorderedRow[col] = row[col];
                    }
                });
                // Add defaults
                reorderedRow.selected = "";
                reorderedRow.reason = reorderedRow.reason || ""; // default empty
                return reorderedRow;
            });

            const thead = document.getElementById('connection-thead');
            const tbody = document.getElementById('connection-tbody');
            thead.innerHTML = "";
            tbody.innerHTML = "";

            // ✅ Create header (skip pdf_name and selected)
            const headerRow = document.createElement('tr');
            Object.keys(data[0]).forEach(key => {
                if (key !== "selected" && key !== "pdf_name") { 
                    const th = document.createElement('th');
                    th.textContent = key.replace('_', ' ').toUpperCase();
                    headerRow.appendChild(th);
                }
                if (key === "index_no") {
                    const previewTh = document.createElement('th');
                    previewTh.textContent = "PREVIEW";
                    headerRow.appendChild(previewTh);
                }
            });
            headerRow.appendChild(document.createElement('th')); // for action buttons
            thead.appendChild(headerRow);

            // ✅ Create rows (skip pdf_name and selected when rendering)
            data.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                tr.id = `index-${row['index_no']}-page-${row['page_number']}`;
                Object.entries(row).forEach(([key, value]) => {
                    if (key !== "selected" && key !== "pdf_name") {
                        const td = document.createElement('td');

                        if (key === "reason") {
                            const textarea = document.createElement('textarea');
                            textarea.value = value;
                            textarea.placeholder = "Enter reason";
                            textarea.rows = 3; // Adjust number of visible lines
                            textarea.style.width = "100%"; // Make it full width
                            textarea.addEventListener('input', (e) => {
                                data[rowIndex].reason = e.target.value;
                            });
                            textarea.addEventListener('click', (e) => e.stopPropagation());
                            td.appendChild(textarea);
                        } else if (key === "index_no") {
                            // Non-editable index_no
                            td.textContent = value;
                            tr.appendChild(td);

                            // ✅ Add Preview button right after index_no
                            const previewTd = document.createElement('td');
                            const previewBtn = document.createElement('button');
                            previewBtn.textContent = "Preview";
                            previewBtn.className = "btn-preview";
                            previewBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const pageNum = row["page_number"];
                                const index_no = row["index_no"];
                                const fileName = row["pdf_name"] || pdfFileName;
                                const imageName = `${fileName}_p${pageNum}_${index_no-1}.png`;

                                const imgIndex = currentDisplayedImages.findIndex(img => {
                                    const currentFileName = img.image_url.split('/').pop();
                                    return currentFileName === imageName;
                                });

                                if (imgIndex !== -1) {
                                    openOverlay(imgIndex, currentDisplayedImages[imgIndex]);
                                } else {
                                    console.warn(`No image found for ${imageName} in currentDisplayedImages`);
                                }
                            });
                            previewTd.appendChild(previewBtn);
                            tr.appendChild(previewTd);

                            return; // skip the rest of the loop for index_no
                        } else if (["wire_no", "page_number"].includes(key)) {
                            td.textContent = value;
                        } else {
                            td.contentEditable = true;
                            td.textContent = value;
                            td.addEventListener('input', () => {
                                data[rowIndex][key] = td.textContent;
                            });
                            td.addEventListener('click', (e) => e.stopPropagation());
                        }

                        tr.appendChild(td);
                    }
                });


                // ✅ Use pdf_name internally but don't display it
                tr.addEventListener('click', () => {
                    const pageNum = row["page_number"];
                    const index_no = row["index_no"];
                    const fileName = row["pdf_name"] || pdfFileName;
                    const imageName = `${fileName}_p${pageNum}_${index_no-1}.png`;

                    const imgIndex = currentDisplayedImages.findIndex(img => {
                        const currentFileName = img.image_url.split('/').pop();
                        return currentFileName === imageName;
                    });

                    if (imgIndex !== -1) {
                        openOverlay(imgIndex, currentDisplayedImages[imgIndex]);
                    } else {
                        console.warn(`No image found for ${imageName} in currentDisplayedImages`);
                    }
                });

                // Action buttons
                const actionTd = document.createElement('td');
                actionTd.style.display = 'flex';
                const rightBtn = document.createElement('button');
                rightBtn.textContent = "Right";
                rightBtn.className = "btn-right";
                rightBtn.id = `right-btn-${row["index_no"]}`; // add unique id
                rightBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    tr.classList.remove('row-wrong');
                    tr.classList.add('row-right');
                    data[rowIndex].selected = "True";
                });

                const wrongBtn = document.createElement('button');
                wrongBtn.textContent = "Wrong";
                wrongBtn.className = "btn-wrong";
                wrongBtn.id = `wrong-btn-${row["index_no"]}`; // add unique id
                wrongBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    tr.classList.remove('row-right');
                    tr.classList.add('row-wrong');
                    data[rowIndex].selected = "False";
                });

                actionTd.appendChild(rightBtn);
                actionTd.appendChild(wrongBtn);
                tr.appendChild(actionTd);

                tbody.appendChild(tr);
            });

            sampleData.connectionData = data;
        }

        function loadAnalysisImages() {
            const container = document.getElementById('analysis-images');
            container.innerHTML = ""; // clear old content

            if (!sampleData.images || sampleData.images.length === 0) return;

            sampleData.images.forEach((imgData) => {
                const pageNum = imgData.page;

                // Create wrapper
                const pageContainer = document.createElement('div');
                pageContainer.classList.add('page-container');

                // Combined Canvas
                pageContainer.innerHTML += `
                    <div class="image-container">
                        <div class="image-header">🖼️ Combined Canvas (Page ${pageNum})</div>
                        <div class="image-display">
                            <img src="${imgData.combined_canvas}" alt="Combined Canvas Page ${pageNum}" />
                        </div>
                    </div>
                `;

                // Junction Points
                pageContainer.innerHTML += `
                    <div class="image-container">
                        <div class="image-header">📍 Junction Points (Page ${pageNum})</div>
                        <div class="image-display">
                            <img src="${imgData.junction_points}" alt="Junction Points Page ${pageNum}" />
                        </div>
                    </div>
                `;

                // Line Canvas
                pageContainer.innerHTML += `
                    <div class="image-container">
                        <div class="image-header">📏 Line Canvas (Page ${pageNum})</div>
                        <div class="image-display">
                            <img src="${imgData.line_canvas}" alt="Line Canvas Page ${pageNum}" />
                        </div>
                    </div>
                `;

                container.appendChild(pageContainer);
            });
        }

        function groupImagesByPage(images) {
            const grouped = {};
            images.forEach(img => {
                if (!grouped[img.page]) {
                    grouped[img.page] = [];
                }
                grouped[img.page].push(img);
            });
            return grouped;
        }

        // Initialize pagination
        let groupedImages = {};
        let pageKeys = []; // list of PDF page numbers
        let currentPageIndex = 0; // index in pageKeys[]
        let currentImagePage = 1; // image pagination within a PDF page
        
        function initializePagination(images) {
            if (images==undefined) return;
            groupedImages = groupImagesByPage(images);
            pageKeys = Object.keys(groupedImages).sort((a, b) => a - b); 
            currentPageIndex = 0;
            currentImagePage = 1;

            document.getElementById('total-pages').textContent = pageKeys.length;
            displayImagesForPage(currentPageIndex, currentImagePage);
            updatePaginationControls();
        }

        function displayImagesForPage(pageIndex, imagePage) {
            const grid = document.getElementById('images-grid');
            grid.innerHTML = '';
            const currentPageNum = pageKeys[pageIndex];
            const images = groupedImages[currentPageNum];
            if (images == undefined) {
                throw new Error("No Circuit Diagram Detected on this page");
            }

            let imagesPerPage = images.length;
            const totalImagePages = Math.ceil(images.length / imagesPerPage);

            const startIndex = (imagePage - 1) * imagesPerPage;
            const endIndex = Math.min(startIndex + imagesPerPage, images.length);
            const pageImages = images.slice(startIndex, endIndex);

            // Update header info
            document.getElementById('current-page').textContent = pageIndex + 1;
            document.getElementById('total-images').textContent = images.length;
            document.getElementById('current-range').textContent = 
                `Page ${currentPageNum} — Showing ${startIndex + 1}-${endIndex}`;

            currentDisplayedImages = pageImages;

            pageImages.forEach((imgData, i) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'grid-image';
                imageDiv.innerHTML = `
                    <img src="${imgData.image_url}" alt="${imgData.name}" />
                    <div class="grid-image-info">${imgData.display_name}</div>
                `;

                imageDiv.addEventListener('click', () => openOverlay(i, imgData));
                grid.appendChild(imageDiv);
            });

            // update extra controls for image pagination
            document.getElementById('image-page-info').textContent = 
                `Image Page ${imagePage} of ${totalImagePages}`;

            document.getElementById('prev-image-btn').disabled = imagePage === 1;
            document.getElementById('next-image-btn').disabled = imagePage === totalImagePages;
        }

        function displayImages(page, images) {
            const grid = document.getElementById('images-grid');
            grid.innerHTML = '';
            const startIndex = (page - 1) * imagesPerPage;
            const endIndex = Math.min(startIndex + imagesPerPage, images.length);
            
            // Store currently displayed images for overlay navigation
            currentDisplayedImages = images.slice(startIndex, endIndex);
           
            document.getElementById('current-range').textContent = `${startIndex + 1}-${endIndex}`;
            document.getElementById('current-page').textContent = page;
            
            for (let i = startIndex; i < endIndex; i++) {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'grid-image';
                
                imageDiv.innerHTML = `
                    <img src="${images[i].image_url}" alt="${images[i].name}" />
                    <div class="grid-image-info">${images[i].name}</div>
                `;
                
                // Add click event to open overlay
                // imageDiv.addEventListener('click', () => openOverlay(i - startIndex, images[i]));
                const localIndex = i - startIndex;
                imageDiv.addEventListener('click', () => openOverlay(localIndex, currentDisplayedImages[localIndex]));

                grid.appendChild(imageDiv);
            }
        }

        function markRow(rowIndex, mark) {
            // Ensure rowIndex is treated as a number
            const numericIndex = Number(rowIndex);
            if (isNaN(numericIndex)) {
                console.warn(`Invalid rowIndex "${rowIndex}" passed to markRow.`);
                return;
            }

            const adjustedIndex = numericIndex + 1; // add 1 safely
            const normalizedMark = mark.toLowerCase();

            let btnId = null;
            if (normalizedMark === 'right') {
                btnId = `right-btn-${adjustedIndex}`;
            } else if (normalizedMark === 'wrong') {
                btnId = `wrong-btn-${adjustedIndex}`;
            }

            if (btnId) {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.click(); // programmatically trigger click
                    showStatusOverlay(btn)
                } else {
                    console.warn(`Button with ID "${btnId}" not found.`);
                }
            } else {
                console.warn(`Invalid mark "${mark}" passed to markRow.`);
            }
        }

        function handleEnterKey(e, imageData) {
            if (e.key === 'Enter') {
                e.preventDefault();

                if (e.shiftKey) {
                    // Shift+Enter was pressed
                    markRow(imageData.name, 'Wrong'); 
                } else {
                    // Regular Enter was pressed
                    markRow(imageData.name, 'Right');
                }
            }
        }

        let keydownHandler; // store handler so we can remove it later
        
        function showStatusOverlay(btnElement) {
            if (!btnElement) return;

            const overlayContent = document.getElementById('overlay-content');

            // Remove any previous status div if it exists
            const existingStatus = overlayContent.querySelector('.status-overlay');
            if (existingStatus) {
                existingStatus.remove();
            }

            const parentClass = btnElement.parentElement.parentElement.className;
            let statusDiv = document.createElement('div');
            statusDiv.className = 'status-overlay close-btn'; // reuse close-btn styling if needed
            statusDiv.style.cssText = 'left: 100px; color: black; width: fit-content; border-radius: 20%; padding: 6px;';

            if (parentClass.includes('row-right')) {
                statusDiv.style.background = 'lightgreen';
                statusDiv.textContent = 'Correct';
            } else if (parentClass.includes('row-wrong')) {
                statusDiv.style.background = 'lightcoral';
                statusDiv.textContent = 'Incorrect';
            } else {
                btnElement.parentElement.parentElement.className = '';
                return; // nothing to show
            }

            overlayContent.appendChild(statusDiv);
        }

        function openOverlay(index, imageData) {
            currentOverlayIndex = index;
            const overlay = document.getElementById('image-overlay');
            const overlayImage = document.getElementById('overlay-image');
            const overlayInfo = document.getElementById('overlay-info');

            overlayImage.src = imageData.image_url;
            overlayImage.alt = imageData.display_name;
            overlayImage.dataset.index = imageData.index_no;

            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            const numericIndex = Number(imageData.name);
            const adjustedIndex = numericIndex + 1; // add 1 safely
        
            btnId = `right-btn-${adjustedIndex}`;

            const btnElement = document.getElementById(btnId);
            let tr = btnElement.parentElement.parentElement;  // gets the <tr> element
            let tds = tr.querySelectorAll("td");              // all <td> elements in that row

            function safeText(td) {
            return td.textContent.trim() === "" ? "<N.A>" : td.textContent.trim();
            }

            overlayInfo.textContent = `${safeText(tds[2])}.${safeText(tds[3])} → ${safeText(tds[4])}.${safeText(tds[5])}`;
            showStatusOverlay(btnElement);
            updateOverlayNavigation();

            // Bind Enter key for this image
            bindEnterKey(imageData);
        }

        function closeOverlay() {
            const overlay = document.getElementById('image-overlay');
            overlay.classList.remove('active');
            document.body.style.overflow = '';

            const src = document.getElementById('overlay-image').src;
            const filename = src.split('/').pop(); // "200_BSUPSB-0107_optimized_p8_77.png"

            // Regex to find the number after 'p' and the last number in filename
            const match = filename.match(/p(\d+).*_(\d+)\.png$/);

            if (match) {
                const pNumber = parseInt(match[1], 10); // "8"
                const lastNumber = parseInt(match[2], 10); // "77"
                console.log(pNumber, lastNumber);

                const tableRowToHighlight = document.getElementById(`index-${lastNumber+1}-page-${pNumber}`);
                if (tableRowToHighlight) {
                    tableRowToHighlight.classList.add('custom-highlight');

                    // Remove highlight after 2 seconds (2000 ms)
                    setTimeout(() => {
                        tableRowToHighlight.classList.remove('custom-highlight');
                    }, 3000);
                }
            }

            unbindEnterKey();
        }


        function navigateOverlay(direction) {
            const newIndex = currentOverlayIndex + direction;

            if (newIndex >= 0 && newIndex < currentDisplayedImages.length) {
                currentOverlayIndex = newIndex;
                const imageData = currentDisplayedImages[currentOverlayIndex];

                const overlayImage = document.getElementById('overlay-image');
                const overlayInfo = document.getElementById('overlay-info');

                overlayImage.src = imageData.image_url;
                overlayImage.alt = imageData.display_name;
                overlayImage.dataset.index = imageData.index_no;

                const numericIndex = Number(imageData.name);
                const adjustedIndex = numericIndex + 1; // add 1 safely
            
                btnId = `right-btn-${adjustedIndex}`;

                const btnElement = document.getElementById(btnId);
                let tr = btnElement.parentElement.parentElement;  // gets the <tr> element
                let tds = tr.querySelectorAll("td");              // all <td> elements in that row

                function safeText(td) {
                    return td.textContent.trim() === "" ? "<N.A>" : td.textContent.trim();
                }

                overlayInfo.textContent = `${safeText(tds[2])}.${safeText(tds[3])} → ${safeText(tds[4])}.${safeText(tds[5])}`;

                showStatusOverlay(btnElement);

                updateOverlayNavigation();

                // Rebind Enter key handler for new image
                bindEnterKey(imageData);
            }
        }

        function bindEnterKey(imageData) {
            // Unbind old handler first
            unbindEnterKey();

            keydownHandler = (e) => handleEnterKey(e, imageData);
            document.addEventListener('keydown', keydownHandler);
        }

        
        function unbindEnterKey() {
            if (keydownHandler) {
                document.removeEventListener('keydown', keydownHandler);
                keydownHandler = null;
            }
        }

        function updateOverlayNavigation() {
            const prevBtn = document.getElementById('prev-overlay');
            const nextBtn = document.getElementById('next-overlay');

            prevBtn.disabled = currentOverlayIndex === 0;
            nextBtn.disabled = currentOverlayIndex === currentDisplayedImages.length - 1;
        }


        // Close overlay when clicking outside the image
        document.getElementById('image-overlay').addEventListener('click', function(e) {
            if (e.target === this) {
                closeOverlay();
            }
        });

        // Global listener for Esc and Arrow navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeOverlay();
            } else if (e.key === 'ArrowLeft') {
                navigateOverlay(-1);
            } else if (e.key === 'ArrowRight') {
                navigateOverlay(1);
            }
        });


        // Change page
        function changePage(direction) {
            const newIndex = currentPageIndex + direction;
            if (newIndex >= 0 && newIndex < pageKeys.length) {
                currentPageIndex = newIndex;
                currentImagePage = 1; // reset image page when switching PDF page
                displayImagesForPage(currentPageIndex, currentImagePage);
                updatePaginationControls();
            }
        }
        function changeImagePage(direction) {
            const currentPageNum = pageKeys[currentPageIndex];
            const images = groupedImages[currentPageNum];
            const totalImagePages = Math.ceil(images.length / imagesPerPage);

            const newImagePage = currentImagePage + direction;
            if (newImagePage >= 1 && newImagePage <= totalImagePages) {
                currentImagePage = newImagePage;
                displayImagesForPage(currentPageIndex, currentImagePage);
            }
        }

        function updatePaginationControls() {
            document.getElementById('prev-btn').disabled = currentPageIndex === 0;
            document.getElementById('next-btn').disabled = currentPageIndex === pageKeys.length - 1;
        }

        // Download CSV
        function saveToDatabase(dataType) {
            let data;
            data = sampleData.connectionData; // use your actual data source
            const toastContainer = document.getElementById("toast-custom-container");
            const btn = document.getElementById("save-btn");

            // Disable button & update text
            btn.disabled = true;
            btn.textContent = "⏳ Saving to Database";

            // Clear previous toast
            toastContainer.innerHTML = "";

            fetch('/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(res => {
                if (!res.ok) {
                    // If HTTP status is not 2xx, treat as an error
                    throw new Error(`Server responded with ${res.status}`);
                }
                return res.json();
            })
            .then(res => {
                // ✅ Success handling
                showToast("✅ Saved to Database", "success");
            })
            .catch(err => {
                console.error(err);
                // ❌ Error handling
                showToast("❌ Failed to Save", "error");
            })
            .finally(() => {
                // Re-enable and reset button regardless of outcome
                btn.disabled = false;
                btn.textContent = "📥 Save to Database";
            });


            function showToast(message, type) {
                const toast = document.createElement("div");
                toast.className = `toast-custom toast-custom-${type}`;
                toast.textContent = message;
                toastContainer.appendChild(toast);
            }
        }

        function downloadCSV(dataType) {
            let data, filename;
            
            if (dataType === 'wire-data') {
                data = sampleData.wireData;
                filename = 'wire_analysis.csv';
            } else if (dataType === 'connection-data') {
                data = sampleData.connectionData;
                filename = 'connection_analysis.csv';
            } else if (dataType === 'connection-pairs') {
                const connectionData = sampleData.connectionData;

                data = [
                    ["connection", "page_number"],  // <-- header row
                    ...connectionData.flatMap(conn => {
                        const srcComponent = conn.source_component || "<N.A.>";
                        const srcTerminal = conn.source_terminal || "<N.A.>";
                        const dstComponent = conn.dest_component || "<N.A.>";
                        const dstTerminal = conn.dest_terminal || "<N.A.>";

                        const pair1 = `${srcComponent}-${srcTerminal}/${dstComponent}-${dstTerminal}`;
                        const pair2 = `${dstComponent}-${dstTerminal}/${srcComponent}-${srcTerminal}`;

                        return [[pair1, pair2]];
                    })
                ];


                filename = 'connection_pairs.csv';
            } else {
                console.error('Unknown data type for CSV download:', dataType);
                return;
            }

            if (data == undefined ||data.length === 0) return;

            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(','),
                ...data.map(row => headers.map(header => row[header]).join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Initialize page when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializePage);

        function initializePage() {
            // populateWireTable(sampleData.wireData);
            populateConnectionTable(sampleData.connectionData);
            // loadAnalysisImages();
            initializePagination(sampleData.drawnLines);
        }

        // Handle window resize for responsive canvas
        window.addEventListener('resize', function () {
            if (pdfDoc && currentPdfPage) {
                renderPdfPage(currentPdfPage);
            }
        });

        // Initialize
        // debugLog('Script initialized');
    </script>
{% endblock %}